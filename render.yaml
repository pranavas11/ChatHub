services:
  # 1) SearXNG as a Private Service
  - type: pserv
    name: searxng
    runtime: docker
    region: ohio
    plan: free
    dockerfilePath: ./searxng.dockerfile
    dockerContext: .
    envVars:
      - key: PORT
        value: 8080  # SearXNG listens on 8080

  # 2) Backend (public Web Service so the browser can call it; switch to pserv if you keep it internal)
  - type: web
    name: jupyter-backend
    runtime: docker
    region: ohio
    plan: free
    dockerfilePath: ./backend.dockerfile
    dockerContext: .
    envVars:
      # IMPORTANT: After first deploy, open the SearXNG service in the dashboard -> Connect -> Internal.
      # Copy the exact internal address (example: searxng-abc1:8080) and paste here with http://
      - key: SEARXNG_API_URL
        value: http://searxng:8080
      # If your app can read PORT from env, set it; else keep config.toml at 3001
      - key: PORT
        value: 3001

  # 3) Frontend (Next.js)
  - type: web
    name: jupyter-frontend
    runtime: docker
    region: ohio
    plan: free
    dockerfilePath: ./app.dockerfile
    dockerContext: .
    envVars:
      # These MUST point to the backendâ€™s public URL if the browser calls it directly.
      # After Render creates the backend, replace with its real onrender.com URL or your custom domain.
      - key: NEXT_PUBLIC_API_URL
        value: https://jupyter-backend.onrender.com/api
      - key: NEXT_PUBLIC_WS_URL
        value: wss://jupyter-backend.onrender.com
      - key: NODE_ENV
        value: production
